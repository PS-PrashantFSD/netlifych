{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nexports.__esModule = true;\nexports.default = exports.INITIAL_CSS_LOAD_ERROR = exports.looseToArray = void 0;\nvar _mitt = _interopRequireDefault(require(\"../next-server/lib/mitt\"));\nvar _router = require(\"../next-server/lib/router/router\");\nvar _getAssetPathFromRoute = _interopRequireDefault(require(\"../next-server/lib/router/utils/get-asset-path-from-route\"));\nvar _isDynamic = require(\"../next-server/lib/router/utils/is-dynamic\");\nvar _parseRelativeUrl = require(\"../next-server/lib/router/utils/parse-relative-url\");\nconst looseToArray = input => [].slice.call(input);\nexports.looseToArray = looseToArray;\nfunction hasRel(rel, link) {\n  try {\n    link = document.createElement('link');\n    return link.relList.supports(rel);\n  } catch (_unused) {}\n}\nfunction pageLoadError(route) {\n  return (0, _router.markLoadingError)(new Error(`Error loading ${route}`));\n}\nconst INITIAL_CSS_LOAD_ERROR = Symbol('INITIAL_CSS_LOAD_ERROR');\nexports.INITIAL_CSS_LOAD_ERROR = INITIAL_CSS_LOAD_ERROR;\nconst relPrefetch = hasRel('preload') && !hasRel('prefetch') ?\n// https://caniuse.com/#feat=link-rel-preload\n// macOS and iOS (Safari does not support prefetch)\n'preload' :\n// https://caniuse.com/#feat=link-rel-prefetch\n// IE 11, Edge 12+, nearly all evergreen\n'prefetch';\nconst relPreload = hasRel('preload') ? 'preload' : relPrefetch;\nconst relPreloadStyle = 'fetch';\nconst hasNoModule = 'noModule' in document.createElement('script');\nfunction normalizeRoute(route) {\n  if (route[0] !== '/') {\n    throw new Error(`Route name should start with a \"/\", got \"${route}\"`);\n  }\n  if (route === '/') return route;\n  return route.replace(/\\/$/, '');\n}\nfunction appendLink(href, rel, as, link) {\n  return new Promise((res, rej) => {\n    link = document.createElement('link'); // The order of property assignment here is intentional:\n    if (as) link.as = as;\n    link.rel = rel;\n    link.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;\n    link.onload = res;\n    link.onerror = rej; // `href` should always be last:\n    link.href = href;\n    document.head.appendChild(link);\n  });\n}\nfunction loadScript(url) {\n  return new Promise((res, rej) => {\n    const script = document.createElement('script');\n    if (process.env.__NEXT_MODERN_BUILD && hasNoModule) {\n      script.type = 'module';\n    }\n    script.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;\n    script.src = url;\n    script.onload = res;\n    script.onerror = () => rej(pageLoadError(url));\n    document.body.appendChild(script);\n  });\n}\nclass PageLoader {\n  constructor(buildId, assetPrefix, initialPage) {\n    this.initialPage = void 0;\n    this.buildId = void 0;\n    this.assetPrefix = void 0;\n    this.pageCache = void 0;\n    this.pageRegisterEvents = void 0;\n    this.loadingRoutes = void 0;\n    this.promisedBuildManifest = void 0;\n    this.promisedSsgManifest = void 0;\n    this.promisedDevPagesManifest = void 0;\n    this.initialPage = initialPage;\n    this.buildId = buildId;\n    this.assetPrefix = assetPrefix;\n    this.pageCache = {};\n    this.pageRegisterEvents = (0, _mitt.default)();\n    this.loadingRoutes = {\n      // By default these 2 pages are being loaded in the initial html\n      '/_app': true\n    }; // TODO: get rid of this limitation for rendering the error page\n    if (initialPage !== '/_error') {\n      this.loadingRoutes[initialPage] = true;\n    }\n    this.promisedBuildManifest = new Promise(resolve => {\n      if (window.__BUILD_MANIFEST) {\n        resolve(window.__BUILD_MANIFEST);\n      } else {\n        ;\n        window.__BUILD_MANIFEST_CB = () => {\n          resolve(window.__BUILD_MANIFEST);\n        };\n      }\n    }); /** @type {Promise<Set<string>>} */\n    this.promisedSsgManifest = new Promise(resolve => {\n      if (window.__SSG_MANIFEST) {\n        resolve(window.__SSG_MANIFEST);\n      } else {\n        ;\n        window.__SSG_MANIFEST_CB = () => {\n          resolve(window.__SSG_MANIFEST);\n        };\n      }\n    });\n  }\n  getPageList() {\n    if (false) {\n      return this.promisedBuildManifest.then(buildManifest => buildManifest.sortedPages);\n    } else {\n      if (window.__DEV_PAGES_MANIFEST) {\n        return window.__DEV_PAGES_MANIFEST.pages;\n      } else {\n        if (!this.promisedDevPagesManifest) {\n          this.promisedDevPagesManifest = fetch(`${this.assetPrefix}/_next/static/development/_devPagesManifest.json`).then(res => res.json()).then(manifest => {\n            ;\n            window.__DEV_PAGES_MANIFEST = manifest;\n            return manifest.pages;\n          }).catch(err => {\n            console.log(`Failed to fetch devPagesManifest`, err);\n          });\n        }\n        return this.promisedDevPagesManifest;\n      }\n    }\n  } // Returns a promise for the dependencies for a particular route\n  getDependencies(route) {\n    return this.promisedBuildManifest.then(m => {\n      return m[route] ? m[route].map(url => `${this.assetPrefix}/_next/${encodeURI(url)}`) : Promise.reject(pageLoadError(route));\n    });\n  } /**\n    * @param {string} href the route href (file-system path)\n    * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n    */\n  getDataHref(href, asPath, ssg, locale) {\n    const {\n      pathname: hrefPathname,\n      query,\n      search\n    } = (0, _parseRelativeUrl.parseRelativeUrl)(href);\n    const {\n      pathname: asPathname\n    } = (0, _parseRelativeUrl.parseRelativeUrl)(asPath);\n    const route = normalizeRoute(hrefPathname);\n    const getHrefForSlug = path => {\n      const dataRoute = (0, _router.addLocale)((0, _getAssetPathFromRoute.default)(path, '.json'), locale);\n      return (0, _router.addBasePath)(`/_next/data/${this.buildId}${dataRoute}${ssg ? '' : search}`);\n    };\n    const isDynamic = (0, _isDynamic.isDynamicRoute)(route);\n    const interpolatedRoute = isDynamic ? (0, _router.interpolateAs)(hrefPathname, asPathname, query).result : '';\n    return isDynamic ? interpolatedRoute && getHrefForSlug(interpolatedRoute) : getHrefForSlug(route);\n  } /**\n    * @param {string} href the route href (file-system path)\n    * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n    */\n  prefetchData(href, asPath, locale) {\n    const {\n      pathname: hrefPathname\n    } = (0, _parseRelativeUrl.parseRelativeUrl)(href);\n    const route = normalizeRoute(hrefPathname);\n    return this.promisedSsgManifest.then((s, _dataHref) =>\n    // Check if the route requires a data file\n    s.has(route) && (\n    // Try to generate data href, noop when falsy\n    _dataHref = this.getDataHref(href, asPath, true, locale)) &&\n    // noop when data has already been prefetched (dedupe)\n    !document.querySelector(`link[rel=\"${relPrefetch}\"][href^=\"${_dataHref}\"]`) &&\n    // Inject the `<link rel=prefetch>` tag for above computed `href`.\n    appendLink(_dataHref, relPrefetch, 'fetch').catch(() => {/* ignore prefetch error */}));\n  }\n  loadPage(route) {\n    route = normalizeRoute(route);\n    return new Promise((resolve, reject) => {\n      // If there's a cached version of the page, let's use it.\n      const cachedPage = this.pageCache[route];\n      if (cachedPage) {\n        if ('error' in cachedPage) {\n          reject(cachedPage.error);\n        } else {\n          resolve(cachedPage);\n        }\n        return;\n      }\n      const fire = pageToCache => {\n        this.pageRegisterEvents.off(route, fire);\n        delete this.loadingRoutes[route];\n        if ('error' in pageToCache) {\n          reject(pageToCache.error);\n        } else {\n          resolve(pageToCache);\n        }\n      }; // Register a listener to get the page\n      this.pageRegisterEvents.on(route, fire);\n      if (!this.loadingRoutes[route]) {\n        this.loadingRoutes[route] = true;\n        if (false) {\n          this.getDependencies(route).then(deps => {\n            const pending = [];\n            deps.forEach(d => {\n              if (d.endsWith('.js') && !document.querySelector(`script[src^=\"${d}\"]`)) {\n                pending.push(loadScript(d));\n              } // Prefetch CSS as it'll be needed when the page JavaScript\n              // evaluates. This will only trigger if explicit prefetching is\n              // disabled for a <Link>... prefetching in this case is desirable\n              // because we *know* it's going to be used very soon (page was\n              // loaded).\n              if (d.endsWith('.css') && !document.querySelector(`link[rel=\"${relPreload}\"][href^=\"${d}\"]`)) {\n                // This is not pushed into `pending` because we don't need to\n                // wait for these to resolve. To prevent an unhandled\n                // rejection, we swallow the error which is handled later in\n                // the rendering cycle (this is just a preload optimization).\n                appendLink(d, relPreload, relPreloadStyle).catch(() => {/* ignore preload error */});\n              }\n            });\n            return Promise.all(pending);\n          }).catch(err => {\n            // Mark the page as failed to load if any of its required scripts\n            // fail to load:\n            this.pageCache[route] = {\n              error: err\n            };\n            fire({\n              error: err\n            });\n          });\n        } else {\n          // Development only. In production the page file is part of the build manifest\n          route = normalizeRoute(route);\n          let scriptRoute = (0, _getAssetPathFromRoute.default)(route, '.js');\n          const url = `${this.assetPrefix}/_next/static/chunks/pages${encodeURI(scriptRoute)}`;\n          loadScript(url).catch(err => {\n            // Mark the page as failed to load if its script fails to load:\n            this.pageCache[route] = {\n              error: err\n            };\n            fire({\n              error: err\n            });\n          });\n        }\n      }\n    });\n  } // This method if called by the route code.\n  registerPage(route, regFn) {\n    var _this = this;\n    const register = async function register(styleSheets) {\n      try {\n        const mod = await regFn();\n        const pageData = {\n          page: mod.default || mod,\n          mod,\n          styleSheets\n        };\n        _this.pageCache[route] = pageData;\n        _this.pageRegisterEvents.emit(route, pageData);\n      } catch (error) {\n        _this.pageCache[route] = {\n          error\n        };\n        _this.pageRegisterEvents.emit(route, {\n          error\n        });\n      }\n    };\n    if (true) {\n      // Wait for webpack to become idle if it's not.\n      // More info: https://github.com/vercel/next.js/pull/1511\n      if (module.hot && module.hot.status() !== 'idle') {\n        console.log(`Waiting for webpack to become \"idle\" to initialize the page: \"${route}\"`);\n        const check = status => {\n          if (status === 'idle') {\n            ;\n            module.hot.removeStatusHandler(check);\n            register(/* css is handled via style-loader in development */[]);\n          }\n        };\n        module.hot.status(check);\n        return;\n      }\n    }\n    function fetchStyleSheet(href) {\n      return fetch(href).then(res => {\n        if (!res.ok) throw pageLoadError(href);\n        return res.text().then(text => ({\n          href,\n          text\n        }));\n      });\n    }\n    const isInitialLoad = route === this.initialPage;\n    const promisedDeps =\n    // Shared styles will already be on the page:\n    route === '/_app' || // We use `style-loader` in development:\n    true ? Promise.resolve([]) :\n    // Tests that this does not block hydration:\n    // test/integration/css-fixtures/hydrate-without-deps/\n    (isInitialLoad ? Promise.resolve(looseToArray(document.querySelectorAll('link[data-n-p]')).map(e => e.getAttribute('href'))) : this.getDependencies(route).then(deps => deps.filter(d => d.endsWith('.css')))).then(cssFiles =>\n    // These files should've already been fetched by now, so this\n    // should resolve instantly.\n    Promise.all(cssFiles.map(d => fetchStyleSheet(d))).catch(err => {\n      if (isInitialLoad) {\n        Object.defineProperty(err, INITIAL_CSS_LOAD_ERROR, {});\n      }\n      throw err;\n    }));\n    promisedDeps.then(deps => register(deps), error => {\n      this.pageCache[route] = {\n        error\n      };\n      this.pageRegisterEvents.emit(route, {\n        error\n      });\n    });\n  } /**\n    * @param {string} route\n    * @param {boolean} [isDependency]\n    */\n  prefetch(route, isDependency) {\n    // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n    // License: Apache 2.0\n    let cn;\n    if (cn = navigator.connection) {\n      // Don't prefetch if using 2G or if Save-Data is enabled.\n      if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();\n    } /** @type {string} */\n    let url;\n    if (isDependency) {\n      url = route;\n    } else {\n      if (true) {\n        route = normalizeRoute(route);\n        const ext = process.env.__NEXT_MODERN_BUILD && hasNoModule ? '.module.js' : '.js';\n        const scriptRoute = (0, _getAssetPathFromRoute.default)(route, ext);\n        url = `${this.assetPrefix}/_next/static/${encodeURIComponent(this.buildId)}/pages${encodeURI(scriptRoute)}`;\n      }\n    }\n    return Promise.all(document.querySelector(`link[rel=\"${relPrefetch}\"][href^=\"${url}\"]`) ? [] : [url && appendLink(url, relPrefetch, url.endsWith('.css') ? relPreloadStyle : 'script'), false && !isDependency && this.getDependencies(route).then(urls => Promise.all(urls.map(dependencyUrl => this.prefetch(dependencyUrl, true))))]).then(\n    // do not return any data\n    () => {},\n    // swallow prefetch errors\n    () => {});\n  }\n}\nexports.default = PageLoader;","map":{"version":3,"sources":["../../client/page-loader.ts"],"names":["looseToArray","input","slice","call","hasRel","rel","link","document","createElement","relList","supports","pageLoadError","route","Error","INITIAL_CSS_LOAD_ERROR","Symbol","relPrefetch","relPreload","relPreloadStyle","hasNoModule","normalizeRoute","replace","appendLink","href","as","Promise","res","rej","crossOrigin","process","env","__NEXT_CROSS_ORIGIN","onload","onerror","head","appendChild","loadScript","url","script","__NEXT_MODERN_BUILD","type","src","body","PageLoader","initialPage","buildId","assetPrefix","pageCache","pageRegisterEvents","loadingRoutes","promisedBuildManifest","promisedSsgManifest","promisedDevPagesManifest","constructor","resolve","window","__BUILD_MANIFEST","__BUILD_MANIFEST_CB","__SSG_MANIFEST","__SSG_MANIFEST_CB","getPageList","then","buildManifest","sortedPages","__DEV_PAGES_MANIFEST","pages","fetch","json","manifest","catch","err","console","log","getDependencies","m","map","encodeURI","reject","getDataHref","asPath","ssg","locale","pathname","hrefPathname","query","search","asPathname","getHrefForSlug","path","dataRoute","isDynamic","interpolatedRoute","result","prefetchData","s","_dataHref","has","querySelector","loadPage","cachedPage","error","fire","pageToCache","off","on","deps","pending","forEach","d","endsWith","push","all","scriptRoute","registerPage","regFn","register","styleSheets","mod","pageData","page","default","emit","module","hot","status","check","removeStatusHandler","fetchStyleSheet","ok","text","isInitialLoad","promisedDeps","querySelectorAll","e","getAttribute","filter","cssFiles","Object","defineProperty","prefetch","isDependency","cn","navigator","connection","saveData","test","effectiveType","ext","encodeURIComponent","urls","dependencyUrl"],"mappings":"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","sourcesContent":["import { ComponentType } from 'react'\nimport type { ClientSsgManifest } from '../build'\nimport type { ClientBuildManifest } from '../build/webpack/plugins/build-manifest-plugin'\nimport type { MittEmitter } from '../next-server/lib/mitt'\nimport mitt from '../next-server/lib/mitt'\nimport {\n  addBasePath,\n  addLocale,\n  interpolateAs,\n  markLoadingError,\n} from '../next-server/lib/router/router'\nimport getAssetPathFromRoute from '../next-server/lib/router/utils/get-asset-path-from-route'\nimport { isDynamicRoute } from '../next-server/lib/router/utils/is-dynamic'\nimport { parseRelativeUrl } from '../next-server/lib/router/utils/parse-relative-url'\n\nexport const looseToArray = <T extends {}>(input: any): T[] =>\n  [].slice.call(input)\n\nfunction hasRel(rel: string, link?: HTMLLinkElement) {\n  try {\n    link = document.createElement('link')\n    return link.relList.supports(rel)\n  } catch {}\n}\n\nfunction pageLoadError(route: string) {\n  return markLoadingError(new Error(`Error loading ${route}`))\n}\n\nexport const INITIAL_CSS_LOAD_ERROR = Symbol('INITIAL_CSS_LOAD_ERROR')\n\nconst relPrefetch =\n  hasRel('preload') && !hasRel('prefetch')\n    ? // https://caniuse.com/#feat=link-rel-preload\n      // macOS and iOS (Safari does not support prefetch)\n      'preload'\n    : // https://caniuse.com/#feat=link-rel-prefetch\n      // IE 11, Edge 12+, nearly all evergreen\n      'prefetch'\n\nconst relPreload = hasRel('preload') ? 'preload' : relPrefetch\nconst relPreloadStyle = 'fetch'\n\nconst hasNoModule = 'noModule' in document.createElement('script')\n\nfunction normalizeRoute(route: string) {\n  if (route[0] !== '/') {\n    throw new Error(`Route name should start with a \"/\", got \"${route}\"`)\n  }\n\n  if (route === '/') return route\n  return route.replace(/\\/$/, '')\n}\n\nfunction appendLink(\n  href: string,\n  rel: string,\n  as?: string,\n  link?: HTMLLinkElement\n): Promise<any> {\n  return new Promise((res, rej) => {\n    link = document.createElement('link')\n\n    // The order of property assignment here is intentional:\n    if (as) link!.as = as\n    link!.rel = rel\n    link!.crossOrigin = process.env.__NEXT_CROSS_ORIGIN!\n    link!.onload = res\n    link!.onerror = rej\n\n    // `href` should always be last:\n    link!.href = href\n\n    document.head.appendChild(link)\n  })\n}\n\nfunction loadScript(url: string): Promise<any> {\n  return new Promise((res, rej) => {\n    const script = document.createElement('script')\n    if (process.env.__NEXT_MODERN_BUILD && hasNoModule) {\n      script.type = 'module'\n    }\n    script.crossOrigin = process.env.__NEXT_CROSS_ORIGIN!\n    script.src = url\n    script.onload = res\n    script.onerror = () => rej(pageLoadError(url))\n    document.body.appendChild(script)\n  })\n}\n\nexport type StyleSheetTuple = { href: string; text: string }\nexport type GoodPageCache = {\n  page: ComponentType\n  mod: any\n  styleSheets: StyleSheetTuple[]\n}\nexport type PageCacheEntry = { error: any } | GoodPageCache\n\nexport default class PageLoader {\n  private initialPage: string\n  private buildId: string\n  private assetPrefix: string\n  private pageCache: Record<string, PageCacheEntry>\n  private pageRegisterEvents: MittEmitter\n  private loadingRoutes: Record<string, boolean>\n  private promisedBuildManifest?: Promise<ClientBuildManifest>\n  private promisedSsgManifest?: Promise<ClientSsgManifest>\n  private promisedDevPagesManifest?: Promise<any>\n\n  constructor(buildId: string, assetPrefix: string, initialPage: string) {\n    this.initialPage = initialPage\n\n    this.buildId = buildId\n    this.assetPrefix = assetPrefix\n\n    this.pageCache = {}\n    this.pageRegisterEvents = mitt()\n    this.loadingRoutes = {\n      // By default these 2 pages are being loaded in the initial html\n      '/_app': true,\n    }\n\n    // TODO: get rid of this limitation for rendering the error page\n    if (initialPage !== '/_error') {\n      this.loadingRoutes[initialPage] = true\n    }\n\n    this.promisedBuildManifest = new Promise((resolve) => {\n      if ((window as any).__BUILD_MANIFEST) {\n        resolve((window as any).__BUILD_MANIFEST)\n      } else {\n        ;(window as any).__BUILD_MANIFEST_CB = () => {\n          resolve((window as any).__BUILD_MANIFEST)\n        }\n      }\n    })\n\n    /** @type {Promise<Set<string>>} */\n    this.promisedSsgManifest = new Promise((resolve) => {\n      if ((window as any).__SSG_MANIFEST) {\n        resolve((window as any).__SSG_MANIFEST)\n      } else {\n        ;(window as any).__SSG_MANIFEST_CB = () => {\n          resolve((window as any).__SSG_MANIFEST)\n        }\n      }\n    })\n  }\n\n  getPageList() {\n    if (process.env.NODE_ENV === 'production') {\n      return this.promisedBuildManifest!.then(\n        (buildManifest) => buildManifest.sortedPages\n      )\n    } else {\n      if ((window as any).__DEV_PAGES_MANIFEST) {\n        return (window as any).__DEV_PAGES_MANIFEST.pages\n      } else {\n        if (!this.promisedDevPagesManifest) {\n          this.promisedDevPagesManifest = fetch(\n            `${this.assetPrefix}/_next/static/development/_devPagesManifest.json`\n          )\n            .then((res) => res.json())\n            .then((manifest) => {\n              ;(window as any).__DEV_PAGES_MANIFEST = manifest\n              return manifest.pages\n            })\n            .catch((err) => {\n              console.log(`Failed to fetch devPagesManifest`, err)\n            })\n        }\n        return this.promisedDevPagesManifest\n      }\n    }\n  }\n\n  // Returns a promise for the dependencies for a particular route\n  private getDependencies(route: string): Promise<string[]> {\n    return this.promisedBuildManifest!.then((m) => {\n      return m[route]\n        ? m[route].map((url) => `${this.assetPrefix}/_next/${encodeURI(url)}`)\n        : Promise.reject(pageLoadError(route))\n    })\n  }\n\n  /**\n   * @param {string} href the route href (file-system path)\n   * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n   */\n  getDataHref(\n    href: string,\n    asPath: string,\n    ssg: boolean,\n    locale?: string | false\n  ) {\n    const { pathname: hrefPathname, query, search } = parseRelativeUrl(href)\n    const { pathname: asPathname } = parseRelativeUrl(asPath)\n    const route = normalizeRoute(hrefPathname)\n\n    const getHrefForSlug = (path: string) => {\n      const dataRoute = addLocale(getAssetPathFromRoute(path, '.json'), locale)\n      return addBasePath(\n        `/_next/data/${this.buildId}${dataRoute}${ssg ? '' : search}`\n      )\n    }\n\n    const isDynamic: boolean = isDynamicRoute(route)\n    const interpolatedRoute = isDynamic\n      ? interpolateAs(hrefPathname, asPathname, query).result\n      : ''\n\n    return isDynamic\n      ? interpolatedRoute && getHrefForSlug(interpolatedRoute)\n      : getHrefForSlug(route)\n  }\n\n  /**\n   * @param {string} href the route href (file-system path)\n   * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n   */\n  prefetchData(href: string, asPath: string, locale?: string | false) {\n    const { pathname: hrefPathname } = parseRelativeUrl(href)\n    const route = normalizeRoute(hrefPathname)\n    return this.promisedSsgManifest!.then(\n      (s: ClientSsgManifest, _dataHref?: string) =>\n        // Check if the route requires a data file\n        s.has(route) &&\n        // Try to generate data href, noop when falsy\n        (_dataHref = this.getDataHref(href, asPath, true, locale)) &&\n        // noop when data has already been prefetched (dedupe)\n        !document.querySelector(\n          `link[rel=\"${relPrefetch}\"][href^=\"${_dataHref}\"]`\n        ) &&\n        // Inject the `<link rel=prefetch>` tag for above computed `href`.\n        appendLink(_dataHref, relPrefetch, 'fetch').catch(() => {\n          /* ignore prefetch error */\n        })\n    )\n  }\n\n  loadPage(route: string): Promise<GoodPageCache> {\n    route = normalizeRoute(route)\n\n    return new Promise<GoodPageCache>((resolve, reject) => {\n      // If there's a cached version of the page, let's use it.\n      const cachedPage = this.pageCache[route]\n      if (cachedPage) {\n        if ('error' in cachedPage) {\n          reject(cachedPage.error)\n        } else {\n          resolve(cachedPage)\n        }\n        return\n      }\n\n      const fire = (pageToCache: PageCacheEntry) => {\n        this.pageRegisterEvents.off(route, fire)\n        delete this.loadingRoutes[route]\n\n        if ('error' in pageToCache) {\n          reject(pageToCache.error)\n        } else {\n          resolve(pageToCache)\n        }\n      }\n\n      // Register a listener to get the page\n      this.pageRegisterEvents.on(route, fire)\n\n      if (!this.loadingRoutes[route]) {\n        this.loadingRoutes[route] = true\n        if (process.env.NODE_ENV === 'production') {\n          this.getDependencies(route)\n            .then((deps) => {\n              const pending: Promise<any>[] = []\n              deps.forEach((d) => {\n                if (\n                  d.endsWith('.js') &&\n                  !document.querySelector(`script[src^=\"${d}\"]`)\n                ) {\n                  pending.push(loadScript(d))\n                }\n\n                // Prefetch CSS as it'll be needed when the page JavaScript\n                // evaluates. This will only trigger if explicit prefetching is\n                // disabled for a <Link>... prefetching in this case is desirable\n                // because we *know* it's going to be used very soon (page was\n                // loaded).\n                if (\n                  d.endsWith('.css') &&\n                  !document.querySelector(\n                    `link[rel=\"${relPreload}\"][href^=\"${d}\"]`\n                  )\n                ) {\n                  // This is not pushed into `pending` because we don't need to\n                  // wait for these to resolve. To prevent an unhandled\n                  // rejection, we swallow the error which is handled later in\n                  // the rendering cycle (this is just a preload optimization).\n                  appendLink(d, relPreload, relPreloadStyle).catch(() => {\n                    /* ignore preload error */\n                  })\n                }\n              })\n              return Promise.all(pending)\n            })\n            .catch((err) => {\n              // Mark the page as failed to load if any of its required scripts\n              // fail to load:\n              this.pageCache[route] = { error: err }\n              fire({ error: err })\n            })\n        } else {\n          // Development only. In production the page file is part of the build manifest\n          route = normalizeRoute(route)\n          let scriptRoute = getAssetPathFromRoute(route, '.js')\n\n          const url = `${this.assetPrefix}/_next/static/chunks/pages${encodeURI(\n            scriptRoute\n          )}`\n          loadScript(url).catch((err) => {\n            // Mark the page as failed to load if its script fails to load:\n            this.pageCache[route] = { error: err }\n            fire({ error: err })\n          })\n        }\n      }\n    })\n  }\n\n  // This method if called by the route code.\n  registerPage(route: string, regFn: () => any) {\n    const register = async (styleSheets: StyleSheetTuple[]) => {\n      try {\n        const mod = await regFn()\n        const pageData: PageCacheEntry = {\n          page: mod.default || mod,\n          mod,\n          styleSheets,\n        }\n        this.pageCache[route] = pageData\n        this.pageRegisterEvents.emit(route, pageData)\n      } catch (error) {\n        this.pageCache[route] = { error }\n        this.pageRegisterEvents.emit(route, { error })\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Wait for webpack to become idle if it's not.\n      // More info: https://github.com/vercel/next.js/pull/1511\n      if ((module as any).hot && (module as any).hot.status() !== 'idle') {\n        console.log(\n          `Waiting for webpack to become \"idle\" to initialize the page: \"${route}\"`\n        )\n\n        const check = (status: string) => {\n          if (status === 'idle') {\n            ;(module as any).hot.removeStatusHandler(check)\n            register(\n              /* css is handled via style-loader in development */\n              []\n            )\n          }\n        }\n        ;(module as any).hot.status(check)\n        return\n      }\n    }\n\n    function fetchStyleSheet(href: string): Promise<StyleSheetTuple> {\n      return fetch(href).then((res) => {\n        if (!res.ok) throw pageLoadError(href)\n        return res.text().then((text) => ({ href, text }))\n      })\n    }\n\n    const isInitialLoad = route === this.initialPage\n    const promisedDeps: Promise<StyleSheetTuple[]> =\n      // Shared styles will already be on the page:\n      route === '/_app' ||\n      // We use `style-loader` in development:\n      process.env.NODE_ENV !== 'production'\n        ? Promise.resolve([])\n        : // Tests that this does not block hydration:\n          // test/integration/css-fixtures/hydrate-without-deps/\n          (isInitialLoad\n            ? Promise.resolve(\n                looseToArray<HTMLLinkElement>(\n                  document.querySelectorAll('link[data-n-p]')\n                ).map((e) => e.getAttribute('href')!)\n              )\n            : this.getDependencies(route).then((deps) =>\n                deps.filter((d) => d.endsWith('.css'))\n              )\n          ).then((cssFiles) =>\n            // These files should've already been fetched by now, so this\n            // should resolve instantly.\n            Promise.all(cssFiles.map((d) => fetchStyleSheet(d))).catch(\n              (err) => {\n                if (isInitialLoad) {\n                  Object.defineProperty(err, INITIAL_CSS_LOAD_ERROR, {})\n                }\n                throw err\n              }\n            )\n          )\n    promisedDeps.then(\n      (deps) => register(deps),\n      (error) => {\n        this.pageCache[route] = { error }\n        this.pageRegisterEvents.emit(route, { error })\n      }\n    )\n  }\n\n  /**\n   * @param {string} route\n   * @param {boolean} [isDependency]\n   */\n  prefetch(route: string, isDependency?: boolean): Promise<void> {\n    // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n    // License: Apache 2.0\n    let cn\n    if ((cn = (navigator as any).connection)) {\n      // Don't prefetch if using 2G or if Save-Data is enabled.\n      if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve()\n    }\n\n    /** @type {string} */\n    let url\n    if (isDependency) {\n      url = route\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        route = normalizeRoute(route)\n\n        const ext =\n          process.env.__NEXT_MODERN_BUILD && hasNoModule ? '.module.js' : '.js'\n        const scriptRoute = getAssetPathFromRoute(route, ext)\n\n        url = `${this.assetPrefix}/_next/static/${encodeURIComponent(\n          this.buildId\n        )}/pages${encodeURI(scriptRoute)}`\n      }\n    }\n\n    return Promise.all(\n      document.querySelector(`link[rel=\"${relPrefetch}\"][href^=\"${url}\"]`)\n        ? []\n        : [\n            url &&\n              appendLink(\n                url,\n                relPrefetch,\n                url.endsWith('.css') ? relPreloadStyle : 'script'\n              ),\n            process.env.NODE_ENV === 'production' &&\n              !isDependency &&\n              this.getDependencies(route).then((urls) =>\n                Promise.all(\n                  urls.map((dependencyUrl) =>\n                    this.prefetch(dependencyUrl, true)\n                  )\n                )\n              ),\n          ]\n    ).then(\n      // do not return any data\n      () => {},\n      // swallow prefetch errors\n      () => {}\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"script"}