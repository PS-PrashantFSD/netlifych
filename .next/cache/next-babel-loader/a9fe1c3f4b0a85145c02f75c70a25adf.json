{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nexports.__esModule = true;\nexports.default = exports.INITIAL_CSS_LOAD_ERROR = exports.looseToArray = void 0;\nvar _mitt = _interopRequireDefault(require(\"../next-server/lib/mitt\"));\nvar _router = require(\"../next-server/lib/router/router\");\nvar _getAssetPathFromRoute = _interopRequireDefault(require(\"../next-server/lib/router/utils/get-asset-path-from-route\"));\nvar _isDynamic = require(\"../next-server/lib/router/utils/is-dynamic\");\nvar _parseRelativeUrl = require(\"../next-server/lib/router/utils/parse-relative-url\");\nconst looseToArray = input => [].slice.call(input);\nexports.looseToArray = looseToArray;\nfunction hasRel(rel, link) {\n  try {\n    link = document.createElement('link');\n    return link.relList.supports(rel);\n  } catch (_unused) {}\n}\nfunction pageLoadError(route) {\n  return (0, _router.markLoadingError)(new Error(`Error loading ${route}`));\n}\nconst INITIAL_CSS_LOAD_ERROR = Symbol('INITIAL_CSS_LOAD_ERROR');\nexports.INITIAL_CSS_LOAD_ERROR = INITIAL_CSS_LOAD_ERROR;\nconst relPrefetch = hasRel('preload') && !hasRel('prefetch') ?\n// https://caniuse.com/#feat=link-rel-preload\n// macOS and iOS (Safari does not support prefetch)\n'preload' :\n// https://caniuse.com/#feat=link-rel-prefetch\n// IE 11, Edge 12+, nearly all evergreen\n'prefetch';\nconst relPreload = hasRel('preload') ? 'preload' : relPrefetch;\nconst relPreloadStyle = 'fetch';\nconst hasNoModule = 'noModule' in document.createElement('script');\nfunction normalizeRoute(route) {\n  if (route[0] !== '/') {\n    throw new Error(`Route name should start with a \"/\", got \"${route}\"`);\n  }\n  if (route === '/') return route;\n  return route.replace(/\\/$/, '');\n}\nfunction appendLink(href, rel, as, link) {\n  return new Promise((res, rej) => {\n    link = document.createElement('link'); // The order of property assignment here is intentional:\n    if (as) link.as = as;\n    link.rel = rel;\n    link.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;\n    link.onload = res;\n    link.onerror = rej; // `href` should always be last:\n    link.href = href;\n    document.head.appendChild(link);\n  });\n}\nfunction loadScript(url) {\n  return new Promise((res, rej) => {\n    const script = document.createElement('script');\n    if (process.env.__NEXT_MODERN_BUILD && hasNoModule) {\n      script.type = 'module';\n    }\n    script.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;\n    script.src = url;\n    script.onload = res;\n    script.onerror = () => rej(pageLoadError(url));\n    document.body.appendChild(script);\n  });\n}\nclass PageLoader {\n  constructor(buildId, assetPrefix, initialPage) {\n    this.initialPage = void 0;\n    this.buildId = void 0;\n    this.assetPrefix = void 0;\n    this.pageCache = void 0;\n    this.pageRegisterEvents = void 0;\n    this.loadingRoutes = void 0;\n    this.promisedBuildManifest = void 0;\n    this.promisedSsgManifest = void 0;\n    this.promisedDevPagesManifest = void 0;\n    this.initialPage = initialPage;\n    this.buildId = buildId;\n    this.assetPrefix = assetPrefix;\n    this.pageCache = {};\n    this.pageRegisterEvents = (0, _mitt.default)();\n    this.loadingRoutes = {\n      // By default these 2 pages are being loaded in the initial html\n      '/_app': true\n    }; // TODO: get rid of this limitation for rendering the error page\n    if (initialPage !== '/_error') {\n      this.loadingRoutes[initialPage] = true;\n    }\n    this.promisedBuildManifest = new Promise(resolve => {\n      if (window.__BUILD_MANIFEST) {\n        resolve(window.__BUILD_MANIFEST);\n      } else {\n        ;\n        window.__BUILD_MANIFEST_CB = () => {\n          resolve(window.__BUILD_MANIFEST);\n        };\n      }\n    }); /** @type {Promise<Set<string>>} */\n    this.promisedSsgManifest = new Promise(resolve => {\n      if (window.__SSG_MANIFEST) {\n        resolve(window.__SSG_MANIFEST);\n      } else {\n        ;\n        window.__SSG_MANIFEST_CB = () => {\n          resolve(window.__SSG_MANIFEST);\n        };\n      }\n    });\n  }\n  getPageList() {\n    if (true) {\n      return this.promisedBuildManifest.then(buildManifest => buildManifest.sortedPages);\n    } else {\n      if (window.__DEV_PAGES_MANIFEST) {\n        return window.__DEV_PAGES_MANIFEST.pages;\n      } else {\n        if (!this.promisedDevPagesManifest) {\n          this.promisedDevPagesManifest = fetch(`${this.assetPrefix}/_next/static/development/_devPagesManifest.json`).then(res => res.json()).then(manifest => {\n            ;\n            window.__DEV_PAGES_MANIFEST = manifest;\n            return manifest.pages;\n          }).catch(err => {\n            console.log(`Failed to fetch devPagesManifest`, err);\n          });\n        }\n        return this.promisedDevPagesManifest;\n      }\n    }\n  } // Returns a promise for the dependencies for a particular route\n  getDependencies(route) {\n    return this.promisedBuildManifest.then(m => {\n      return m[route] ? m[route].map(url => `${this.assetPrefix}/_next/${encodeURI(url)}`) : Promise.reject(pageLoadError(route));\n    });\n  } /**\n    * @param {string} href the route href (file-system path)\n    * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n    */\n  getDataHref(href, asPath, ssg, locale) {\n    const {\n      pathname: hrefPathname,\n      query,\n      search\n    } = (0, _parseRelativeUrl.parseRelativeUrl)(href);\n    const {\n      pathname: asPathname\n    } = (0, _parseRelativeUrl.parseRelativeUrl)(asPath);\n    const route = normalizeRoute(hrefPathname);\n    const getHrefForSlug = path => {\n      const dataRoute = (0, _router.addLocale)((0, _getAssetPathFromRoute.default)(path, '.json'), locale);\n      return (0, _router.addBasePath)(`/_next/data/${this.buildId}${dataRoute}${ssg ? '' : search}`);\n    };\n    const isDynamic = (0, _isDynamic.isDynamicRoute)(route);\n    const interpolatedRoute = isDynamic ? (0, _router.interpolateAs)(hrefPathname, asPathname, query).result : '';\n    return isDynamic ? interpolatedRoute && getHrefForSlug(interpolatedRoute) : getHrefForSlug(route);\n  } /**\n    * @param {string} href the route href (file-system path)\n    * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n    */\n  prefetchData(href, asPath, locale) {\n    const {\n      pathname: hrefPathname\n    } = (0, _parseRelativeUrl.parseRelativeUrl)(href);\n    const route = normalizeRoute(hrefPathname);\n    return this.promisedSsgManifest.then((s, _dataHref) =>\n    // Check if the route requires a data file\n    s.has(route) && (\n    // Try to generate data href, noop when falsy\n    _dataHref = this.getDataHref(href, asPath, true, locale)) &&\n    // noop when data has already been prefetched (dedupe)\n    !document.querySelector(`link[rel=\"${relPrefetch}\"][href^=\"${_dataHref}\"]`) &&\n    // Inject the `<link rel=prefetch>` tag for above computed `href`.\n    appendLink(_dataHref, relPrefetch, 'fetch').catch(() => {/* ignore prefetch error */}));\n  }\n  loadPage(route) {\n    route = normalizeRoute(route);\n    return new Promise((resolve, reject) => {\n      // If there's a cached version of the page, let's use it.\n      const cachedPage = this.pageCache[route];\n      if (cachedPage) {\n        if ('error' in cachedPage) {\n          reject(cachedPage.error);\n        } else {\n          resolve(cachedPage);\n        }\n        return;\n      }\n      const fire = pageToCache => {\n        this.pageRegisterEvents.off(route, fire);\n        delete this.loadingRoutes[route];\n        if ('error' in pageToCache) {\n          reject(pageToCache.error);\n        } else {\n          resolve(pageToCache);\n        }\n      }; // Register a listener to get the page\n      this.pageRegisterEvents.on(route, fire);\n      if (!this.loadingRoutes[route]) {\n        this.loadingRoutes[route] = true;\n        if (true) {\n          this.getDependencies(route).then(deps => {\n            const pending = [];\n            deps.forEach(d => {\n              if (d.endsWith('.js') && !document.querySelector(`script[src^=\"${d}\"]`)) {\n                pending.push(loadScript(d));\n              } // Prefetch CSS as it'll be needed when the page JavaScript\n              // evaluates. This will only trigger if explicit prefetching is\n              // disabled for a <Link>... prefetching in this case is desirable\n              // because we *know* it's going to be used very soon (page was\n              // loaded).\n              if (d.endsWith('.css') && !document.querySelector(`link[rel=\"${relPreload}\"][href^=\"${d}\"]`)) {\n                // This is not pushed into `pending` because we don't need to\n                // wait for these to resolve. To prevent an unhandled\n                // rejection, we swallow the error which is handled later in\n                // the rendering cycle (this is just a preload optimization).\n                appendLink(d, relPreload, relPreloadStyle).catch(() => {/* ignore preload error */});\n              }\n            });\n            return Promise.all(pending);\n          }).catch(err => {\n            // Mark the page as failed to load if any of its required scripts\n            // fail to load:\n            this.pageCache[route] = {\n              error: err\n            };\n            fire({\n              error: err\n            });\n          });\n        } else {\n          // Development only. In production the page file is part of the build manifest\n          route = normalizeRoute(route);\n          let scriptRoute = (0, _getAssetPathFromRoute.default)(route, '.js');\n          const url = `${this.assetPrefix}/_next/static/chunks/pages${encodeURI(scriptRoute)}`;\n          loadScript(url).catch(err => {\n            // Mark the page as failed to load if its script fails to load:\n            this.pageCache[route] = {\n              error: err\n            };\n            fire({\n              error: err\n            });\n          });\n        }\n      }\n    });\n  } // This method if called by the route code.\n  registerPage(route, regFn) {\n    var _this = this;\n    const register = async function register(styleSheets) {\n      try {\n        const mod = await regFn();\n        const pageData = {\n          page: mod.default || mod,\n          mod,\n          styleSheets\n        };\n        _this.pageCache[route] = pageData;\n        _this.pageRegisterEvents.emit(route, pageData);\n      } catch (error) {\n        _this.pageCache[route] = {\n          error\n        };\n        _this.pageRegisterEvents.emit(route, {\n          error\n        });\n      }\n    };\n    if (false) {\n      // Wait for webpack to become idle if it's not.\n      // More info: https://github.com/vercel/next.js/pull/1511\n      if (module.hot && module.hot.status() !== 'idle') {\n        console.log(`Waiting for webpack to become \"idle\" to initialize the page: \"${route}\"`);\n        const check = status => {\n          if (status === 'idle') {\n            ;\n            module.hot.removeStatusHandler(check);\n            register(/* css is handled via style-loader in development */[]);\n          }\n        };\n        module.hot.status(check);\n        return;\n      }\n    }\n    function fetchStyleSheet(href) {\n      return fetch(href).then(res => {\n        if (!res.ok) throw pageLoadError(href);\n        return res.text().then(text => ({\n          href,\n          text\n        }));\n      });\n    }\n    const isInitialLoad = route === this.initialPage;\n    const promisedDeps =\n    // Shared styles will already be on the page:\n    route === '/_app' || // We use `style-loader` in development:\n    false ? Promise.resolve([]) :\n    // Tests that this does not block hydration:\n    // test/integration/css-fixtures/hydrate-without-deps/\n    (isInitialLoad ? Promise.resolve(looseToArray(document.querySelectorAll('link[data-n-p]')).map(e => e.getAttribute('href'))) : this.getDependencies(route).then(deps => deps.filter(d => d.endsWith('.css')))).then(cssFiles =>\n    // These files should've already been fetched by now, so this\n    // should resolve instantly.\n    Promise.all(cssFiles.map(d => fetchStyleSheet(d))).catch(err => {\n      if (isInitialLoad) {\n        Object.defineProperty(err, INITIAL_CSS_LOAD_ERROR, {});\n      }\n      throw err;\n    }));\n    promisedDeps.then(deps => register(deps), error => {\n      this.pageCache[route] = {\n        error\n      };\n      this.pageRegisterEvents.emit(route, {\n        error\n      });\n    });\n  } /**\n    * @param {string} route\n    * @param {boolean} [isDependency]\n    */\n  prefetch(route, isDependency) {\n    // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n    // License: Apache 2.0\n    let cn;\n    if (cn = navigator.connection) {\n      // Don't prefetch if using 2G or if Save-Data is enabled.\n      if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();\n    } /** @type {string} */\n    let url;\n    if (isDependency) {\n      url = route;\n    } else {\n      if (false) {\n        route = normalizeRoute(route);\n        const ext = process.env.__NEXT_MODERN_BUILD && hasNoModule ? '.module.js' : '.js';\n        const scriptRoute = (0, _getAssetPathFromRoute.default)(route, ext);\n        url = `${this.assetPrefix}/_next/static/${encodeURIComponent(this.buildId)}/pages${encodeURI(scriptRoute)}`;\n      }\n    }\n    return Promise.all(document.querySelector(`link[rel=\"${relPrefetch}\"][href^=\"${url}\"]`) ? [] : [url && appendLink(url, relPrefetch, url.endsWith('.css') ? relPreloadStyle : 'script'), true && !isDependency && this.getDependencies(route).then(urls => Promise.all(urls.map(dependencyUrl => this.prefetch(dependencyUrl, true))))]).then(\n    // do not return any data\n    () => {},\n    // swallow prefetch errors\n    () => {});\n  }\n}\nexports.default = PageLoader;","map":null,"metadata":{},"sourceType":"script"}