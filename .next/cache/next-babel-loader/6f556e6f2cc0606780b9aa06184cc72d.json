{"ast":null,"code":"function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nconst DEFAULT_OPTIONS = {\n  background: '#000',\n  completeRatio: 1,\n  enabled: true,\n  onComplete: null,\n  onProgress: null,\n  size: 40\n};\nconst getElementComputedStyled = (element, prop) => parseFloat(getComputedStyle(element, null)[prop].replace('px', ''));\nconst factory = () => {\n  let _canvas = null;\n  let _context = null;\n  let _data = {};\n  const _handleEraserProgress = (currentX, currentY) => {\n    const {\n      colParts,\n      numParts,\n      completeRatio,\n      enabled,\n      size,\n      onComplete,\n      onProgress\n    } = _data;\n    if (!enabled) return;\n    let p = Math.floor(currentX / size) + Math.floor(currentY / size) * colParts;\n    if (p >= 0 && p < numParts) {\n      _data.ratio += _data.parts[p];\n      _data.parts[p] = 0;\n      if (!_data.complete) {\n        p = _data.ratio / _data.numParts;\n        if (p >= completeRatio) {\n          _data.complete = true;\n          if (onComplete) {\n            onComplete();\n          }\n          return;\n        }\n        if (onProgress) {\n          onProgress(p);\n        }\n      }\n    }\n  };\n  const _onMouseMove = event => {\n    event.preventDefault();\n    const {\n      enabled,\n      posX,\n      posY,\n      scaleRatio,\n      touchX,\n      touchY\n    } = _data;\n    const currentX = (event.pageX - posX) * scaleRatio;\n    const currentY = (event.pageY - posY) * scaleRatio;\n    if (enabled) {\n      _handleEraserProgress(currentX, currentY);\n      _context.beginPath();\n      _context.moveTo(touchX, touchY);\n      _context.lineTo(currentX, currentY);\n      _context.stroke();\n    }\n    _data.touchX = currentX;\n    _data.touchY = currentY;\n  };\n  const _onMouseDown = event => {\n    event.preventDefault();\n    const {\n      enabled,\n      posX,\n      posY,\n      scaleRatio\n    } = _data;\n    const currentX = (event.pageX - posX) * scaleRatio;\n    const currentY = (event.pageY - posY) * scaleRatio;\n    _data.touchDown = true;\n    _data.touchX = currentX;\n    _data.touchY = currentY;\n    if (enabled) {\n      _handleEraserProgress(currentX, currentY);\n      _context.beginPath();\n      _context.moveTo(currentX - 1, currentY);\n      _context.lineTo(currentX, currentY);\n      _context.stroke();\n    }\n    _canvas.addEventListener('mousemove', _onMouseMove);\n  };\n  const _onMouseClick = event => {\n    event.preventDefault();\n    const {\n      enabled,\n      posX,\n      posY,\n      scaleRatio\n    } = _data;\n    const currentX = (event.pageX - posX) * scaleRatio;\n    const currentY = (event.pageY - posY) * scaleRatio;\n    _data.touchDown = true;\n    _data.touchX = currentX;\n    _data.touchY = currentY;\n    if (enabled) {\n      _handleEraserProgress(currentX, currentY);\n      _context.beginPath();\n      _context.moveTo(currentX - 1, currentY);\n      _context.lineTo(currentX, currentY);\n      _context.stroke();\n    }\n    _canvas.addEventListener('mousemove', _onMouseMove);\n  };\n  const init = (source, options = {}) => {\n    if (!source) {\n      throw new Error('No source element provided. It must be an HTML canvas element.');\n    }\n    const currentOptions = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS), options);\n    const {\n      size,\n      background\n    } = currentOptions;\n    _canvas = source;\n    _context = _canvas.getContext('2d');\n    const devicePixelRatio = window.devicePixelRatio || 1;\n    const backingStoreRatio = _context.webkitBackingStorePixelRatio || _context.mozBackingStorePixelRatio || _context.msBackingStorePixelRatio || _context.oBackingStorePixelRatio || _context.backingStorePixelRatio || 1;\n    const scaleRatio = devicePixelRatio / backingStoreRatio;\n    const realWidth = getElementComputedStyled(_canvas, 'width');\n    const realHeight = getElementComputedStyled(_canvas, 'height');\n    const width = realWidth * scaleRatio;\n    const height = realHeight * scaleRatio;\n    if (devicePixelRatio !== backingStoreRatio) {\n      _canvas.width = width;\n      _canvas.height = height;\n      _canvas.style.width = `${realWidth}px`;\n      _canvas.style.height = `${realHeight}px`;\n    } else {\n      _canvas.width = realWidth;\n      _canvas.height = realHeight;\n      _canvas.style.width = '';\n      _canvas.style.height = '';\n    }\n\n    // _context.scale(scaleRatio, scaleRatio);\n    _context.fillStyle = background;\n    _context.fillRect(0, 0, width, height);\n    _context.drawImage(_canvas, 0, 0, width, height);\n\n    // prepare context for drawing operations\n    _context.globalCompositeOperation = 'destination-out';\n    _context.lineWidth = size;\n    _context.lineCap = 'round';\n\n    // bind events\n    _canvas.addEventListener('mouseenter', _onMouseDown);\n    _canvas.addEventListener('click', _onMouseClick);\n    // _canvas.addEventListener('touchstart', _onTouchStart);\n    // _canvas.addEventListener('touchmove', _onTouchMove);\n    // _canvas.addEventListener('touchend', _onTouchEnd);\n\n    // reset parts\n    const parts = [];\n    const colParts = Math.floor(width / size);\n    const numParts = colParts * Math.floor(height / size);\n    for (let i = 0; i < numParts; i++) {\n      parts.push(1);\n    }\n    _data = _objectSpread({\n      posX: _canvas.offsetLeft,\n      posY: _canvas.offsetTop,\n      touchDown: false,\n      touchID: -999,\n      touchX: 0,\n      touchY: 0,\n      ptouchX: 0,\n      ptouchY: 0,\n      w: width,\n      h: height,\n      scaleRatio,\n      ratio: 0,\n      complete: false,\n      currentOptions\n    }, currentOptions);\n  };\n  const clear = () => {\n    const {\n      w,\n      h,\n      numParts,\n      onComplete\n    } = _data;\n    if (_data) {\n      _context.clearRect(0, 0, w, h);\n      for (let i = 0; i < numParts; i++) {\n        _data.parts[i] = 0;\n      }\n      _data.ratio = numParts;\n      _data.complete = true;\n      if (onComplete) {\n        onComplete();\n      }\n    }\n  };\n  const reset = () => {\n    const {\n      w,\n      h,\n      numParts\n    } = _data;\n    _context.globalCompositeOperation = 'source-over';\n    _context.drawImage(_canvas, 0, 0, w, h);\n    _context.globalCompositeOperation = 'destination-out';\n    for (let i = 0; i < numParts; i++) {\n      _data.parts[i] = 1;\n    }\n    _data.ratio = 0;\n    _data.complete = false;\n    _data.touchDown = false;\n  };\n  return {\n    init,\n    clear,\n    reset\n  };\n};\nexport default factory;","map":null,"metadata":{},"sourceType":"module"}